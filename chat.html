<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>실시간 자유 채팅방</title>
    <style>
      :root {
        font-family: 'Pretendard', 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        line-height: 1.6;
        color: #f5f7fb;
        background-color: #050915;
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, rgba(64, 179, 255, 0.2), transparent 60%),
          radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.08), transparent 40%), #050915;
      }

      .page {
        max-width: 960px;
        margin: 0 auto;
        padding: 48px 20px 80px;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 28px;
      }

      header h1 {
        margin: 0;
        font-size: clamp(2rem, 3vw, 2.8rem);
      }

      header p {
        margin: 0;
        color: #9fb3c8;
      }

      .actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .actions a,
      .actions button {
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 999px;
        padding: 10px 18px;
        background: transparent;
        color: inherit;
        text-decoration: none;
        cursor: pointer;
        transition: border-color 0.2s ease, color 0.2s ease;
        font-size: 0.95rem;
      }

      .actions a:hover,
      .actions button:hover {
        border-color: #71c4ff;
        color: #71c4ff;
      }

      .panel {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.07);
        border-radius: 18px;
        padding: 24px;
        box-shadow: 0 15px 60px rgba(15, 20, 30, 0.4);
        backdrop-filter: blur(8px);
        margin-bottom: 18px;
      }

      .panel h2 {
        margin: 0 0 8px;
        font-size: 1.2rem;
      }

      .panel-note {
        color: #9fb3c8;
        font-size: 0.95rem;
        margin: 0 0 14px;
      }

      .status-text {
        font-size: 0.95rem;
        color: #d6dfeb;
        margin: 0 0 14px;
      }

      .messages {
        max-height: 420px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding-right: 4px;
      }

      .message {
        padding: 14px 16px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .message .meta {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        font-size: 0.85rem;
        color: #9fb3c8;
        margin-bottom: 6px;
      }

      .message .author {
        font-weight: 600;
        color: #f5f7fb;
      }

      .message .author.anonymous {
        color: #ffda79;
      }

      .empty {
        text-align: center;
        color: #9fb3c8;
        font-size: 0.95rem;
      }

      .error {
        color: #ffb3b3;
        font-size: 0.95rem;
        margin: 8px 0 0;
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-top: 16px;
      }

      textarea {
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 12px 14px;
        background: rgba(0, 0, 0, 0.25);
        color: #f5f7fb;
        font-size: 1rem;
        resize: vertical;
        min-height: 110px;
      }

      textarea:focus {
        outline: none;
        border-color: #71c4ff;
        box-shadow: 0 0 0 2px rgba(113, 196, 255, 0.15);
      }

      .form-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9rem;
        color: #cdd7e8;
      }

      .toggle input {
        width: 18px;
        height: 18px;
        accent-color: #71c4ff;
      }

      .primary-btn {
        border: none;
        border-radius: 999px;
        padding: 10px 20px;
        font-size: 0.95rem;
        cursor: pointer;
        transition: opacity 0.2s ease, transform 0.1s ease;
        color: #050915;
        background: linear-gradient(135deg, #71c4ff, #3dd598);
      }

      .primary-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .primary-btn:not(:disabled):active {
        transform: scale(0.98);
      }

      .notice {
        padding: 14px 16px;
        border-radius: 12px;
        border: 1px dashed rgba(255, 255, 255, 0.25);
        background: rgba(255, 255, 255, 0.02);
        color: #cdd7e8;
        font-size: 0.95rem;
      }

      footer {
        margin-top: 48px;
        text-align: center;
        color: #6e7d94;
        font-size: 0.85rem;
      }

      @media (max-width: 640px) {
        .page {
          padding: 32px 16px 60px;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header>
        <h1>실시간 자유 채팅방</h1>
        <p>로그인한 사용자는 익명 또는 아이디 공개로 대화에 참여할 수 있습니다.</p>
        <div class="actions">
          <a href="/">메인으로 돌아가기</a>
          <button type="button" id="refresh-btn">즉시 새로고침</button>
        </div>
      </header>

      <section class="panel">
        <h2>대화 목록</h2>
        <p class="panel-note">3초마다 자동으로 최신 메시지를 불러옵니다.</p>
        <p class="status-text" id="status-text">최근 대화 불러오는 중...</p>
        <div class="messages" id="chat-messages"></div>
        <p class="empty" id="empty-state" hidden>아직 대화가 없습니다. 첫 메시지를 남겨보세요!</p>
        <p class="error" id="chat-error" hidden></p>
      </section>

      <section class="panel">
        <h2>메시지 보내기</h2>
        <p class="panel-note">한 번에 최대 500자까지 입력할 수 있습니다.</p>
        <div class="notice" id="login-notice" hidden>
          로그인 정보가 필요합니다. <a href="/" style="color: #71c4ff">메인 페이지</a>에서 로그인한 후 다시 돌아오세요.
        </div>
        <div class="notice" id="profile-box" hidden></div>
        <form id="chat-form">
          <textarea id="chat-input" name="chat-content" placeholder="지금 떠오르는 이야기를 적어보세요"></textarea>
          <div class="form-actions">
            <label class="toggle">
              <input type="checkbox" id="chat-anon" checked />
              <span>익명으로 보내기</span>
            </label>
            <button class="primary-btn" type="submit" id="send-btn" disabled>메시지 전송</button>
          </div>
          <p class="error" id="form-error" hidden></p>
        </form>
      </section>

      <footer>© 자유 채팅방 · Django REST API와 Vue SPA 기반</footer>
    </div>

    <script>
      ;(() => {
        const TOKEN_STORAGE_KEY = 'codex_auth_token'
        const CHAT_LIMIT = 80
        const POLL_INTERVAL = 3000

        const chatMessagesEl = document.getElementById('chat-messages')
        const emptyStateEl = document.getElementById('empty-state')
        const chatErrorEl = document.getElementById('chat-error')
        const statusTextEl = document.getElementById('status-text')
        const formErrorEl = document.getElementById('form-error')
        const loginNoticeEl = document.getElementById('login-notice')
        const profileBoxEl = document.getElementById('profile-box')
        const chatFormEl = document.getElementById('chat-form')
        const textareaEl = document.getElementById('chat-input')
        const anonCheckboxEl = document.getElementById('chat-anon')
        const sendBtnEl = document.getElementById('send-btn')
        const refreshBtn = document.getElementById('refresh-btn')

        let token = null
        let currentUser = null
        let pollTimer = null
        let isLoading = false

        const resolveRuntimeBase = () => {
          if (window.API_BASE_URL) return window.API_BASE_URL
          if (window.location.hostname?.endsWith('github.io')) {
            return 'https://15-164-232-40.nip.io/api'
          }
          if (window.location.origin) {
            return `${window.location.origin}/api`
          }
          return '/api'
        }

        const API_BASE_URL = resolveRuntimeBase().replace(/\/$/, '')
        const buildUrl = (path) => `${API_BASE_URL}${path.startsWith('/') ? path : `/${path}`}`

        const readToken = () => {
          try {
            token = window.localStorage?.getItem(TOKEN_STORAGE_KEY) || null
          } catch {
            token = null
          }
          return token
        }

        const setElementVisibility = (el, shouldShow) => {
          if (!el) return
          el.hidden = !shouldShow
        }

        const renderMessages = (messages) => {
          chatMessagesEl.innerHTML = ''
          if (!messages.length) {
            setElementVisibility(emptyStateEl, true)
            return
          }
          setElementVisibility(emptyStateEl, false)
          messages.forEach((message) => {
            const wrapper = document.createElement('article')
            wrapper.className = 'message'

            const meta = document.createElement('div')
            meta.className = 'meta'

            const author = document.createElement('span')
            author.className = 'author'
            if (message.is_anonymous) {
              author.classList.add('anonymous')
            }
            author.textContent = message.display_name || (message.is_anonymous ? '익명' : '사용자')

            const timestamp = document.createElement('time')
            timestamp.textContent = new Intl.DateTimeFormat('ko-KR', {
              dateStyle: 'short',
              timeStyle: 'short',
            }).format(new Date(message.created_at))

            meta.appendChild(author)
            meta.appendChild(timestamp)

            const body = document.createElement('p')
            body.textContent = message.content

            wrapper.appendChild(meta)
            wrapper.appendChild(body)
            chatMessagesEl.appendChild(wrapper)
          })
          chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight
        }

        const handleFetchError = (targetEl, message, error) => {
          console.error(message, error)
          if (targetEl) {
            targetEl.textContent = message
            setElementVisibility(targetEl, true)
          }
        }

        const loadChatMessages = async ({ silent = false } = {}) => {
          if (isLoading) return
          isLoading = true
          if (!silent) {
            statusTextEl.textContent = '대화를 불러오는 중...'
          }
          setElementVisibility(chatErrorEl, false)
          try {
            const response = await fetch(buildUrl(`/chat/messages?limit=${CHAT_LIMIT}`), {
              headers: { Accept: 'application/json', ...(token ? { Authorization: `Token ${token}` } : {}) },
            })
            if (!response.ok) {
              throw new Error(`채팅 조회 실패 (${response.status})`)
            }
            const payload = await response.json()
            renderMessages(Array.isArray(payload?.messages) ? payload.messages : [])
            const now = new Date()
            statusTextEl.textContent = `마지막 업데이트: ${now.toLocaleTimeString('ko-KR')}`
          } catch (error) {
            handleFetchError(chatErrorEl, '채팅 데이터를 불러오지 못했습니다.', error)
          } finally {
            isLoading = false
          }
        }

        const stopPolling = () => {
          if (pollTimer) {
            clearInterval(pollTimer)
            pollTimer = null
          }
        }

        const startPolling = () => {
          stopPolling()
          pollTimer = window.setInterval(() => loadChatMessages({ silent: true }), POLL_INTERVAL)
        }

        const updateFormState = () => {
          const enabled = Boolean(currentUser)
          textareaEl.disabled = !enabled
          anonCheckboxEl.disabled = !enabled
          sendBtnEl.disabled = !enabled || !textareaEl.value.trim()
          setElementVisibility(loginNoticeEl, !enabled)
          setElementVisibility(profileBoxEl, enabled)
          if (enabled && currentUser) {
            profileBoxEl.textContent = `${currentUser.username} 님으로 접속 중입니다. (${currentUser.email || '이메일 정보 없음'})`
          }
        }

        const fetchProfile = async () => {
          if (!token) {
            currentUser = null
            updateFormState()
            return
          }
          try {
            const response = await fetch(buildUrl('/auth/profile'), {
              headers: {
                Accept: 'application/json',
                Authorization: `Token ${token}`,
              },
            })
            if (!response.ok) {
              throw new Error('프로필 확인 실패')
            }
            const payload = await response.json()
            currentUser = payload?.user ?? null
          } catch (error) {
            console.warn('토큰 확인 실패', error)
            currentUser = null
            token = null
          } finally {
            updateFormState()
          }
        }

        const submitChat = async (event) => {
          event.preventDefault()
          setElementVisibility(formErrorEl, false)
          if (!currentUser || !token) {
            handleFetchError(formErrorEl, '로그인 후 이용해 주세요.', null)
            return
          }
          const content = textareaEl.value.trim()
          if (!content) {
            handleFetchError(formErrorEl, '메시지를 입력해 주세요.', null)
            return
          }
          sendBtnEl.disabled = true
          try {
            const response = await fetch(buildUrl('/chat/messages'), {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
                Authorization: `Token ${token}`,
              },
              body: JSON.stringify({
                content,
                is_anonymous: anonCheckboxEl.checked,
              }),
            })
            if (!response.ok) {
              const payload = await response.json().catch(() => ({}))
              const detail = payload?.detail || '메시지를 전송하지 못했습니다.'
              throw new Error(detail)
            }
            textareaEl.value = ''
            sendBtnEl.disabled = true
            await loadChatMessages({ silent: true })
          } catch (error) {
            handleFetchError(formErrorEl, error.message || '메시지를 전송하지 못했습니다.', error)
          } finally {
            sendBtnEl.disabled = !textareaEl.value.trim()
          }
        }

        const init = async () => {
          readToken()
          await fetchProfile()
          await loadChatMessages()
          startPolling()
        }

        textareaEl.addEventListener('input', () => {
          sendBtnEl.disabled = !currentUser || !textareaEl.value.trim()
        })
        chatFormEl.addEventListener('submit', submitChat)
        refreshBtn.addEventListener('click', () => loadChatMessages({ silent: false }))

        window.addEventListener('storage', (event) => {
          if (event.key === TOKEN_STORAGE_KEY) {
            readToken()
            fetchProfile()
          }
        })

        init()
      })()
    </script>
  </body>
</html>
